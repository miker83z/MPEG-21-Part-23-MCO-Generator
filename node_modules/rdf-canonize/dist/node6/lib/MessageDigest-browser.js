/*
 * Copyright (c) 2016-2020 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

require('setimmediate');

const crypto = self.crypto || self.msCrypto; // TODO: synchronous version no longer supported in browser

module.exports = class MessageDigest {
  /**
   * Creates a new MessageDigest.
   *
   * @param algorithm the algorithm to use.
   */
  constructor(algorithm) {
    // check if crypto.subtle is available
    // check is here rather than top-level to only fail if class is used
    if (!(crypto && crypto.subtle)) {
      throw new Error('crypto.subtle not found.');
    }

    if (algorithm === 'sha256') {
      this.algorithm = {
        name: 'SHA-256'
      };
    } else if (algorithm === 'sha1') {
      this.algorithm = {
        name: 'SHA-1'
      };
    } else {
      throw new Error(`Unsupport algorithm "${algorithm}".`);
    }

    this._content = '';
  }

  update(msg) {
    this._content += msg;
  }

  digest() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const data = new TextEncoder().encode(_this._content);
      const buffer = new Uint8Array(yield crypto.subtle.digest(_this.algorithm, data)); // return digest in hex

      let hex = '';

      for (let i = 0; i < buffer.length; ++i) {
        hex += buffer[i].toString(16).padStart(2, '0');
      }

      return hex;
    })();
  }

};